<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two Sine Waves</title>
  <style>
    :root { --w: 860px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color: #111; }
    h1 { font-size: 20px; margin: 0 0 14px; }
    .wrap { max-width: var(--w); }
    .panel { border: 1px solid #ddd; border-radius: 12px; padding: 14px; margin: 12px 0; }
    .row { display: grid; grid-template-columns: 120px 1fr; gap: 12px; align-items: center; margin: 10px 0; }
    .controls { display: grid; grid-template-columns: 130px 1fr 120px; gap: 10px; align-items: center; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:active { transform: translateY(1px); }
    canvas { width: 100%; height: 160px; border-radius: 10px; border: 1px solid #e3e3e3; background: #fafafa; display: block; }
    input[type="range"] { width: 100%; }
    .value { font-variant-numeric: tabular-nums; text-align: right; }
    .hint { color: #555; font-size: 13px; margin-top: 10px; }
    .badge { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; color:#333; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Two Sine Waves (independent)</h1>
    <div class="hint">
      <span class="badge">Note</span> Browsers require a user gesture to start audio. Click <b>Start</b> on a wave.
    </div>

    <div class="panel" id="waveA">
      <h2 style="font-size:16px;margin:0 0 10px;">Sine Wave A</h2>
      <div class="row">
        <div>Controls</div>
        <div class="controls">
          <button class="toggle">Start</button>
          <div></div>
          <div class="value status">Stopped</div>
        </div>
      </div>

      <div class="row">
        <div>Pitch</div>
        <div class="controls">
          <input class="freq" type="range" min="40" max="2000" step="1" value="440" />
          <div class="value"><span class="freqVal">440</span> Hz</div>
          <button class="preset" data-hz="440">A4</button>
        </div>
      </div>

      <div class="row">
        <div>Amplitude</div>
        <div class="controls">
          <input class="amp" type="range" min="0" max="1" step="0.001" value="0.2" />
          <div class="value"><span class="ampVal">0.200</span></div>
          <button class="mute">Mute</button>
        </div>
      </div>

      <canvas class="scope" width="900" height="200"></canvas>
    </div>

    <div class="panel" id="waveB">
      <h2 style="font-size:16px;margin:0 0 10px;">Sine Wave B</h2>
      <div class="row">
        <div>Controls</div>
        <div class="controls">
          <button class="toggle">Start</button>
          <div></div>
          <div class="value status">Stopped</div>
        </div>
      </div>

      <div class="row">
        <div>Pitch</div>
        <div class="controls">
          <input class="freq" type="range" min="40" max="2000" step="1" value="660" />
          <div class="value"><span class="freqVal">660</span> Hz</div>
          <button class="preset" data-hz="660">E5</button>
        </div>
      </div>

      <div class="row">
        <div>Amplitude</div>
        <div class="controls">
          <input class="amp" type="range" min="0" max="1" step="0.001" value="0.2" />
          <div class="value"><span class="ampVal">0.200</span></div>
          <button class="mute">Mute</button>
        </div>
      </div>

      <canvas class="scope" width="900" height="200"></canvas>
    </div>
  </div>

<script>
(() => {
  // Single shared AudioContext so both waves can run simultaneously.
  let audioCtx = null;

  function getAudioCtx() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
  }

  function createWaveController(rootEl) {
    const toggleBtn = rootEl.querySelector(".toggle");
    const muteBtn = rootEl.querySelector(".mute");
    const presetBtn = rootEl.querySelector(".preset");
    const statusEl = rootEl.querySelector(".status");

    const freqSlider = rootEl.querySelector(".freq");
    const ampSlider  = rootEl.querySelector(".amp");
    const freqValEl  = rootEl.querySelector(".freqVal");
    const ampValEl   = rootEl.querySelector(".ampVal");

    const canvas = rootEl.querySelector(".scope");
    const ctx2d = canvas.getContext("2d", { alpha: false });

    // Audio nodes (created on first start)
    let osc = null;
    let gain = null;
    let analyser = null;

    let running = false;
    let muted = false;
    let lastAmpBeforeMute = parseFloat(ampSlider.value);

    // Drawing buffer
    const analyserSize = 2048;
    const data = new Uint8Array(analyserSize);

    function updateLabels() {
      freqValEl.textContent = String(freqSlider.value);
      ampValEl.textContent = Number(ampSlider.value).toFixed(3);
    }

    function setStatus() {
      statusEl.textContent = running ? "Playing" : "Stopped";
      toggleBtn.textContent = running ? "Stop" : "Start";
    }

    function ensureNodes() {
      if (osc) return;

      const ac = getAudioCtx();

      osc = ac.createOscillator();
      osc.type = "sine";

      gain = ac.createGain();
      gain.gain.value = parseFloat(ampSlider.value);

      analyser = ac.createAnalyser();
      analyser.fftSize = analyserSize;

      // Chain: osc -> gain -> analyser -> destination
      osc.connect(gain);
      gain.connect(analyser);
      analyser.connect(ac.destination);

      osc.frequency.value = parseFloat(freqSlider.value);
    }

    function start() {
      const ac = getAudioCtx();
      ensureNodes();

      // Resume context if needed (autoplay policy)
      if (ac.state !== "running") ac.resume();

      // Oscillator can only be started once; if previously stopped, recreate.
      if (!osc || running) return;

      // Safety: oscillators can only be started once; ensureNodes created fresh if osc null.
      osc.start();
      running = true;
      setStatus();
    }

    function stop() {
      if (!running) return;

      try { osc.stop(); } catch (_) {}
      try { osc.disconnect(); } catch (_) {}
      try { gain.disconnect(); } catch (_) {}
      try { analyser.disconnect(); } catch (_) {}

      osc = null;
      gain = null;
      analyser = null;

      running = false;
      setStatus();
    }

    function setFreq(hz) {
      hz = Math.max(1, Number(hz) || 0);
      if (osc) {
        const ac = getAudioCtx();
        osc.frequency.setTargetAtTime(hz, ac.currentTime, 0.01);
      }
    }

    function setAmp(a) {
      a = Math.min(1, Math.max(0, Number(a) || 0));
      if (gain) {
        const ac = getAudioCtx();
        gain.gain.setTargetAtTime(a, ac.currentTime, 0.01);
      }
    }

    function draw() {
      requestAnimationFrame(draw);

      // Clear
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);

      // Background
      ctx2d.fillStyle = "#fafafa";
      ctx2d.fillRect(0, 0, canvas.width, canvas.height);

      // Midline
      ctx2d.strokeStyle = "#ddd";
      ctx2d.lineWidth = 1;
      ctx2d.beginPath();
      ctx2d.moveTo(0, canvas.height / 2);
      ctx2d.lineTo(canvas.width, canvas.height / 2);
      ctx2
